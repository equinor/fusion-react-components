import { getDynamicStyles } from 'jss';
import type { Jss } from 'jss';
import type { StyleRules } from '../types';

/**
 * Map of class names generated by JSS
 * Keys are the style rule names, values are the generated CSS class names
 */
export interface ClassNameMap {
  [key: string]: string;
}

/**
 * Internal structure for caching stylesheet entries
 */
interface SheetEntry {
  /** Reference count - tracks how many components are using this sheet */
  refs: number;
  /** Static stylesheet classes (don't change based on props) */
  staticSheet: ClassNameMap;
  /** Dynamic styles that need to be recalculated based on props */
  dynamicStyles: unknown;
}

/**
 * JSS stylesheet interface
 */
interface JssSheet {
  /** Attach the stylesheet to the DOM */
  attach: () => void;
  /** Update dynamic styles with new props */
  update: (props: Record<string, unknown>) => void;
  /** Generated class names map */
  classes: ClassNameMap;
}

/**
 * Options for creating a JSS stylesheet
 */
interface JssOptions {
  /** Whether this is a linked sheet (for dynamic styles) */
  link?: boolean;
  /** Class name generator function */
  generateId?: (rule: { key: string }, sheet?: unknown) => string;
  /** Name prefix for debugging */
  name?: string;
  /** Theme object */
  theme?: unknown;
}

/**
 * Simple sheet manager for caching and reusing JSS stylesheets
 *
 * This manager implements a caching strategy to avoid recreating stylesheets
 * for the same styles/theme combination. It separates static and dynamic styles
 * for optimal performance.
 *
 * Key features:
 * - Reference counting for cleanup
 * - Separation of static and dynamic styles
 * - Caching based on name + theme combination
 */
class SheetManager {
  /** Cache of stylesheets keyed by name-theme combination */
  private sheets = new Map<string, SheetEntry>();

  /**
   * Gets or creates a JSS stylesheet for the given styles
   *
   * This method implements a caching strategy:
   * 1. Creates a cache key from name + theme
   * 2. If cached, increments reference count and returns cached classes
   * 3. If not cached, creates static sheet and extracts dynamic styles
   * 4. For dynamic styles, creates a linked sheet that updates with props
   * 5. Merges static and dynamic class names
   *
   * @param styles - Style rules object
   * @param theme - Theme object
   * @param name - Name prefix for the stylesheet
   * @param jss - JSS instance
   * @param generateClassName - Class name generator function
   * @param props - Props for dynamic styles (optional)
   * @returns Map of class names (rule key -> CSS class name)
   */
  getOrCreateSheet(
    styles: StyleRules,
    theme: unknown,
    name: string,
    jss: Jss,
    generateClassName: (rule: { key: string }, sheet?: unknown) => string,
    props: Record<string, unknown> = {},
  ): ClassNameMap {
    // Create cache key from name and theme (stringified)
    const key = `${name}-${JSON.stringify(theme)}`;
    let sheetEntry = this.sheets.get(key);

    if (!sheetEntry) {
      // Create static sheet (styles that don't depend on props)
      // Note: We use type assertions because JSS types don't perfectly match our StyleRules type
      // @ts-expect-error JSS types don't match our StyleRules type exactly - this is safe
      const staticSheet = jss.createStyleSheet(styles, {
        link: false, // Static sheets don't need to be linked (can't update)
        generateId: generateClassName,
        name,
        theme,
      } as JssOptions) as JssSheet;
      staticSheet.attach();

      sheetEntry = {
        refs: 0,
        staticSheet: staticSheet.classes,
        // Extract dynamic styles (functions that depend on props)
        // @ts-expect-error JSS types don't match our StyleRules type exactly - this is safe
        dynamicStyles: getDynamicStyles(styles),
      };
      this.sheets.set(key, sheetEntry);
    }

    // Increment reference count (multiple components can use the same sheet)
    sheetEntry.refs += 1;

    // Handle dynamic styles (if any)
    if (sheetEntry.dynamicStyles) {
      // Create linked sheet for dynamic styles (can be updated)
      const dynamicSheet = jss.createStyleSheet(sheetEntry.dynamicStyles, {
        link: true, // Linked sheets can be updated when props change
        generateId: generateClassName,
        name,
        theme,
      } as JssOptions) as JssSheet;
      // Update dynamic styles with current props
      dynamicSheet.update(props);
      dynamicSheet.attach();

      // Merge static and dynamic class names (dynamic takes precedence)
      return {
        ...sheetEntry.staticSheet,
        ...dynamicSheet.classes,
      };
    }

    // No dynamic styles, return static classes only
    return sheetEntry.staticSheet;
  }

  /**
   * Removes a reference to a sheet
   */
  removeSheet(key: string): void {
    const sheetEntry = this.sheets.get(key);
    if (sheetEntry) {
      sheetEntry.refs -= 1;
      if (sheetEntry.refs <= 0) {
        this.sheets.delete(key);
      }
    }
  }

  /**
   * Clears all sheets
   */
  clear(): void {
    this.sheets.clear();
  }
}

/**
 * Default sheet manager instance
 */
export const defaultSheetManager = new SheetManager();

export { SheetManager };
export type { SheetManager as SheetManagerType };
