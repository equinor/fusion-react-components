import { Meta, Story, Canvas, ArgsTable } from '@storybook/addon-docs/blocks';

<Meta
  title="Filterpane/Filterprovider"
  parameters={{
    viewMode: 'docs',
    previewTabs: {
      canvas: { hidden: true },
    },
  }}
/>

# Fusion Filterprovider

The FilterProvider is a stand alone context that delivers filtering capabilites to your app.
While the filterpane comes with some built out UI components, these are optional to use or for inspiration.
The filterprovider itself can be used as a wrapper around any component, to handle filtering off a dataset.

## General Implementation and usage

```jsx
const myApp = () => {
  const myData:Data[] = fetchData();

  const myFilterDefinition:Filter<Data[],string[]> = {
    key:'myFilter',
    title:'My Filter',
    optionsBuilderFn: (data) => builOptions(data),
    filterFn: (data,selection) => filterTheData(data,selection)
  }

  return (
    <FilterProvider initialData={myData} />
      <CheckBoxFilter filter={myFilterDefinition} />
      <MyDataTable />
    </FilterProvider>
  );
};

const MyDataTable = () => {
  const { filteredData } = useFilterStore();

  return ( <div>{filteredData.map((d)=>printoutData(d))} <div> );
};
```

This is a bare minimum implementation for the FilterProvider, to get any use out of it.
We have a CheckBoxFilter, that is a filter and MyDataTable that will access the filteredData.
The CheckBoxFilter register its filterFn with the filterProvider.  
When a selection is made the Provider runs the filterFn, and MyDataTable can access the data from the useFilterStore hook.

## Registering Filters and filtering

For the provider to have any functionality we need to have filters registered with the provider.
If not, the full dataset will always go straight through untouched.
The prebuilt CheckBoxFilters registers them self automatically with the provider.
If you are building your own filter components, you need to handle the registering process yourself.
When they are registered the FilterFn is added to the FilterFunctionStore.
When a user does a selection, the provider will send the full dataset through each of the filter functions added to the store.

## Adding multiple filters

You can add as many filters as you need. They are all added as children components inside the `provider`.
The same filter component can be used multiple times, just make sure the `key` is unique.
As long as the `FilterFn` is registered with the `provider`, the filter will be used.

## Interacting with the Filterprovider context

### useFilterStore hook

As shown in the example this hooks used to get hold of the filteredData, but theres more.

```jsx
const { filteredData, selection, store } = useFilterStore();
```

filteredData is a `useState` . When the provides filteredData changes, state gets update and exposed through filteredData
selection is also a `useState`. This updates whenever a selection in the filters changes. Back from this you will get all the selections that are made in all registered filters.
store is the entire FilterStore Context object, this is the same as accessing the context directly with `useFilterContext`

### useFilterContext

Gives access to the store only. This `store` is the same as the store provided by `useFilterStore`.
But it dosnt have the state handling for filteredData and selection, which might be beneficial, when they are not needed.

```jsx
const { store } = useFilterContext();
```

### Data access

#### data$

Provides the filtered data for use in your app.

#### filterSelectionData

Get filtered data for given Filter key, to be used for getting filter Options.
This will return a filtered dataset, without filtering on the given filter key.

#### selections$

Provides all the selections from each filter that has been made.
This is what the filtering functions receives when the filtering process runs.

### Selection and Filter handling functions

#### registerFilterSettings

Add the filter settings created for your filter to the filterSetting store.

#### getFilterSetting

Get filter settings from the FilterSettings store.

#### registerFilter

Register a filters filter function in the filterfunction store.
When registered this function is used in combination with the filter selection to filter the dataset.
Both are identified by the filter Key.

#### unRegisterFilter

Remove a registered filter function from the filterFunction store.
This filter function no longer be used in the filtering process, even if a selection still exist in selections$

#### updateFilterSelection

updates the selection for given key in selections$.
This replaces the current selection.
So how items are added and removed to the selections itself, needs to be handled by the filter component.

#### clearSingleFilterSelection

clear(empties) the selection for a give filter key.
Uses supplied `resetFilterFn` if supplied, else set the selection to `''`
If the filters `noFilterReset` is `true`, this function has no effect.

#### clearAllFilterSelections

Functions in same matter as `clearSingleFilterSelection`, but loops through all selections$ and resets them.
`resetFilterFn` and `noFilterReset` is taken into account.

#### registerSelection

Adds a new key value pair in selections$

#### unregisterSelection

Removes a key-value pair from the selections$

#### setFilterSelections

Overwrite all current register selections with the supplied selections

#### setData

Overwrite the current dataset with a new dataset.
Will trigger new filtering based on current selection.
