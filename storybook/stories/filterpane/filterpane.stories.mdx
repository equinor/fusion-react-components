import { Meta, Story, Canvas, ArgsTable } from '@storybook/addon-docs/blocks';
import { useState } from 'react';
import Filterpane from './filterpane';
import { firstNameCheck, lastNameCheck, ageCheck, statusRadio } from './filterDefinitions';
import { FilterProvider, CheckBoxFilter, RadioFilter, GeneralBar, FilterSection } from '../../../packages/filterpane';
import { makeData, Person } from './functions';

<Meta
  title="Filterpane/FilterPane"
  parameters={{
    viewMode: 'docs',
  }}
/>

# Filterpane components

These components are build to cover common use cases for a general filter panel.
The components are build to work interchangeably, as inspiration or something to build off of.

export const Pane = (args) => <Filterpane {...args} />;

export const CheckBox = (args) => (
  <FilterProvider initialData={args.data}>
    <CheckBoxFilter filter={firstNameCheck} useSelectAll useSearch useSingleSelect />
  </FilterProvider>
);

export const Radio = (args) => (
  <FilterProvider initialData={args.data} initialFilters={{ status: 'all' }}>
    <RadioFilter filter={statusRadio} useSearch />
  </FilterProvider>
);

export const General = (args) => {
  const [minimized, setMinimized] = useState(false);
  return (
    <FilterProvider initialData={args.data}>
      <GeneralBar onMinimize={() => setMinimized((s) => !s)} minimized={minimized} searchFilterFn={() => {}} />
    </FilterProvider>
  );
};

export const Filtersection = (args) => {
  return (
    <FilterProvider initialData={args.data} initialFilters={{ firstName: [] }}>
      <FilterSection useFilterSelector>
        <CheckBoxFilter filter={{ ...firstNameCheck }} />
        <CheckBoxFilter filter={{ ...lastNameCheck }} />
      </FilterSection>
    </FilterProvider>
  );
};

<Story name="Filterpane" args={{ amount: 12 }}>
  {Pane}
</Story>

The above filterpane is structured in code like this :

```jsx
<FilterProvider initialData={data} initialFilters={{ status: 'all', firstName: [] }}>
  <FilterPanel>
    <GeneralBar onMinimize={() => setMinimized((s) => !s)} minimized={minimized} searchFilterFn={searchFilterFn} />
    <FilterSection isMinimized={minimized} useFilterSelector>
      <CheckBoxFilter filter={{ ...firstNameCheck }} useSelectAll useSearch />
      <CheckBoxFilter filter={{ ...lastNameCheck }} useSelectAll useSearch />
      <CheckBoxFilter filter={{ ...ageCheck }} useSelectAll useSearch />
      <RadioFilter filter={statusRadio} />
    </FilterSection>
  </FilterPanel>
</FilterProvider>
```

## FilterProvider

the filter provider is the only give component in this hierarchy. It provides the context that is used in all the other components.
`initialData` is our dataset.
`initialFilters` set a default filter state on load. Here we have added an object for status and firstName.
These are then added to `selections$`. This is why the they are set as `selected` in the Filter Categories.
status also set to `all`, this is why all is the selected radio.
If names was added to the `firstName` object, they would also be selected.

## FilterPanel

A simple container panel with no acutal features to it. just some styling making this a horizontal flowing FilterPanel.

## GeneralBar

<Canvas>
  <Story name="GeneralBar" args={{ data: makeData(12) }}>
    {General}
  </Story>
</Canvas>

A general purpose bar that gives some basic features. It has a `search bar` that searches and filters the dataset based on
the supplied searchFilterFn. `onMinimize` and `minimized` is used for the Hide/Show filter button. In this scenario the minimized
state will hide the FilterSection. `Clear filters` clears all the filter selections. This functionality comes from the FilterProvider.
When minimized The bar will show a set of chips as a summary of your selection, if any are done. The bar will handle `children`
if added. They will flow after the buttons/chips.

## FilterSections

<Canvas>
  <Story name="Filtersection" args={{ data: makeData(12) }}>
    {Filtersection}
  </Story>
</Canvas>

This area holds all the filter controllers we have added.
if you implement `useFilterSelector`, you will se the Filter Categories box.
In the Filter Categories you can see the filters that are registered.
If you check one of the filters they will show up in the area to the right.
The selector uses the initialFilters to decide which filters should show up on load.
If no initialFilters given, are will be empty.
A filter marked as `mandatory`, will be show, but disabled. As seen with the `status` filter.

If `useFilterSelector` is not used. All registered filters will be shown at all times.

Using `useFilterSelector` is handy when you have large dataset and many filter categories.
Since all categories needs to be recalculated with each selection, performance can become an issue.

## Filter Settings

The filters you want to use needs to be added to the filter provider.
For them to work with the provider, the filter needs to register its filter settings.
The filter settings can be expanded on if needed, but the base settings are as following

```tsx
Filter<TData, TSelection> = {
  key: string;
  title: string;
  optionsBuilderFn: FilterOptionsFn<TData>;
  mandatory?: boolean;
  noFilterReset?: boolean;
  filterFn?: FilterFn<TData, TSelection>;
  counterFn?: (data: TData) => FilterCounters;
  resetFilterFn?: (currentSelection?: TSelection) => TSelection;
  description?: string;
  priority?: number;
}
```

### TData and TSelection

`TData` is the type of your data.
`TSelection` is this specific filters selection type. for example array of string for a checkbox filter. Or just a string if you can only select one.

### Key, title, description

`Key` is a unique name the provider and supporting function uses to identify this filter.
While `title` is the filter name that should be shown to users. In pre-built filters, this is used as the header.
`description (optional)` , and can be used to give more context to filters. In pre-built filters the `description` is shown when hovering the title.
One might want to use this when the options in a filter is in some way altered data, calculated or any other reason why the filter might not be directly identifiable.
`priority (optional)` is used by the built in `FilterSection`, its a way to manipulate the sort order. a lower number, means it will be added closer to the front.
Can also be used if you make your own `FilterSection` component.

### mandatory and priority

`mandatory (optional)` tells the provider that this filter should always be part of the selections and filterFn. It is not possible to remove it from selected filters, if that functionality is used.
When using the FilterSelector, a mandatory filter will be disabled. If you make your own selector filter. Be aware that filterprovider "selection" functions takes the mandatory tag into account when trying to remove filters.
`priority (optional)` is used by the built in `FilterSection`, its a way to manipulate the sort order. a lower number, means it will be added closer to the front.
Can also be used if you make your own `FilterSection` component.

### noFilterReset and resetFilterFn

`noFilterReset (optional)` is taken into account when trying to trigger reset functions in the provider. If true, this filter will not be reset.
`resetFilterFn (optional`, a function that gives instructions on how a filter should be reset. This is use full if you have a filter that should not be emptied when reset.
Example a radio selector, should on reset be reset back to a specific choice.  
If no `resetFilterFn` is supplied the filter will be sett to a empty string (`''`).
For `mandatory` one of these options might be usefull, to avoid it getting blanked out.

## optionsBuilderFn

Describes how to find and build all the options that should be available in the filters.
It should return a record of FilterOptions. A FilterOptions contains a `key`, `label` and an optional `searchString`.
`key` is a string identifier. `label` is (on built in components) the text shown next to its selector. This can be a component itself or just a string.
`searchString (optional)` gives i used (on built in component) to search for given option internally. If not supplied label will be used.
If the label is a component, the searchString is use full. Or if you want to have some extra info on the search that does not make sense in the search

## counterFn

This is optional. If not supplied counter will not be shown for built in filter components.
There is also no way to know how many times a options occurs in the current dataset.
This will remove built in components capability to filter itself when options become unavailable.
Be ware that the `counterFn` runs every time any filter selection is made.
The `counterFn` will receive the remaining dataset after it has been filtered.
It should return a record with filter Options keys as object key and a number for occurrences.

## filterFn

This is Optional. The `filterFn` describes how the filterprovider should filter the dataset for this filter.
the function receives the partly filtered dataset and the current selection for this filter key.
Then this function need to filter the dataset appropriately , and return the remaining dataset.
"why would I not supply i filterFN, its a filter after all ?", you might wonder.
Not giving a filter function means you can register a FilterSetting, that isnt really a filter.
but it belong here, and has a type of selection, you want to control.
An example of this is a "grouping options". If your consumer of the filterprovider has differnt ways to display the data.
Using the radio selector, without a filterFn, gives you an easy way to keep track of the grouping in the same way as other filters.
Without it actually affecting the dataset directly.

## Filter setting and custom built filter components

If you create your own filter component, the filtersetting is not mandatory to use in its entirety
but be aware that some of these properties are used by the filterProvider directly.
This includes:

- key
- mandatory
- filterFn
- resetFilterFn
- noFilterReset

you must have a unique key. The rest is not mandatory. But for the functionality these properties represent, you need to use these property name.

#### CheckBoxFilter

<Canvas>
  <Story name="CheckBox" args={{ data: makeData(12) }}>
    {CheckBox}
  </Story>
</Canvas>

A standard filter controller using checkboxes.
Expects its selections to be an array.
`filter` takes in an Filter object that has all the necessary setup (see filter settings).
`useSelectAll` add a button on top of the options, that (de)selects all options.
use full when there are many options, and user want to remove just a few options.
`useSearch` adds a search bar to the filter. This searches within the filter options.
Use for a user to find a specific options, when there are many options.

filter options are dynamic and will populate when doing selection in other filters.
If the counter hits 0, the options will disappear.
It can happen that a selected option has a 0 counter. These will still show, for clarity.

> This filter unregister itself on component unmount.

#### RadioFilter

<Canvas>
  <Story name="Radio" args={{ data: makeData(12) }}>
    {Radio}
  </Story>
</Canvas>

a standard filter controller using radio button.
Expects its selection to be a singular `string`.  
`filter` is the same object as in Checkboxes (see filter settings)
`useSearch` adds a search bar to the filter. This searches within the filter options.
Use for a user to find a specific options, when there are many options.

Filter options are not dynamic. Meaning they will not be added removed based on the other filters.

> This filter unregister itself on component unmount.

#### Registering Filters and filter Settings

For a filter to be an active filter it needs to be registered with the filterprovider.
The pre-built filters (radio and checkbox) does this itself.
When the filter-component loads. It registers its filterFn and filterSettings with the provider.
This means that the filterProvider will use the filters FilterFn, when it runs it filtering process.
In the same way it "unregister" itself when a the component is unmounted.
Meaning the filterFn is removed from the filtering process.

In the prebuilt filters they are added like this

```tsx
useEffect(() => {
  filterFn && store.registerFilter(key, filterFn);
  store.registerFilterSettings(filter);
  return () => store.unRegisterFilter(key);
}, [store, key, filterFn, filter]);
```

> Be ware of the register and unregister. If you for example want to hide the component,  
> and unmounts the component in the process. Might give you some unintended consequences.  
> If using a plane `display: none` in css is not an option. you should think abit about how you register and unregister your filter.

If you want to show hide your filterpane. It is recommended to to this through css.
By hiding the container. If you unload, the filter process will run and filtered dataset will change.

In the above example, you can se the filterSetting is registered. This is not removed on unload.
Meaning all the filtersSettings that are once registered, will be available in the provider for its entire lifecycle.
The filter Provider will use this when accessing settings some settings like mandatory, resetFilterFn and some others.
