import { Meta, Story, Canvas, ArgsTable } from '@storybook/addon-docs/blocks';

<Meta title="Filterpane/Filterprovider" />

# Fusion Filterprovider

The FilterProvider is a stand alone context that delivers filtering capabilites to your app.
While the filterpane comes with some built out UI components, these are optional to use or for inspiration.
The filterprovider itself can be used as a wrapper around any component, to handle filtering off a dataset.

## General Implementation and usage

```jsx
const myApp = () => {
  const myData:Data[] = fetchData();

  const myFilterDefintion:Filter<Data[],string[]> = {
    key:'myFilter',
    title:'My Filter',
    optionsBuilderFn: (data) => builOptions(data),
    filterFn: (data,selection) => filterTheData(data,selection)
  }

  return (
    <FilterProvider initialData={myData} />
      <CheckBoxFilter filter={myFilterDefintion} />
      <MyDataTable />
    </FilterProvider>
  );
};

const MyDataTable = () => {
  const { filteredData } = useFilterStore();

  return ( <div>{filteredData.map((d)=>printoutData(d))} <div> );
};
```

This is a bare minimum implementation for the FilterProvider, to get any use out of it.
We have a CheckBoxFilter, that is a filter and MyDataTable that will access the filteredData.
The CheckBoxFilter register its filterFn with the filterProvider.  
When a selection is made the Provider runs the filterFn, and MyDataTable can access the data from the useFilterStore hook.

## Registering Filters and filtering

For the provider to have any functionality we need to have filters registered with the provider.
If not, the full dataset will always go straight through untouched.
The prebuilt CheckBoxFilters registers them self automatically with the provider.
If you are building your own filter components, you need to handle the registering process yourself.
When they are registered the FilterFn is added to the FilterFunctionStore.
When a user does a selection, the provider will send the full dataset through each of the filter functions added to the store.

## Adding multiple filters

You can add as many filters as you need. They are all added as children components inside the `provider`.
The same filter component can be used multiple times, just make sure the `key` is unique.
As long as the `FilterFn` is registered with the `provider`, the filter will be used.

## Interacting with the Filterprovider context

### useFilterStore hook

As shown in the example this hooks used to get hold of the filteredData, but theres more.

```jsx
const { filteredData, selection, store } = useFilterStore();
```

filteredData is a `useState` . When the provides filteredData changes, state gets update and exposed through filteredData
selection is also a `useState`. This updates whenever a selection in the filters changes. Back from this you will get all the selections that are made in all registered filters.
store is the entire FilterStore Context object, this is the same as accessing the context directly with `useContext`

### The FilterStore Context

Accessed through the useFilterStore or through `useContext`

```jsx
const store = useFilterStore(FilterContext);
```

This gives your access to the entire machine that is the Filter Provider
