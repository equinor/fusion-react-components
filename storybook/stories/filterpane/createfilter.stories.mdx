import { Meta, Story, Canvas, ArgsTable } from '@storybook/addon-docs/blocks';
import {
  FilterProvider,
  CheckBoxFilter,
  RadioFilter,
  GeneralBar,
  FilterSection,
  Filter,
} from '../../../packages/filterpane';

<Meta
  title="Filterpane/Create custom filter"
  parameters={{
    viewMode: 'docs',
    previewTabs: {
      canvas: { hidden: true },
    },
  }}
/>

# Create a custom filter

The filerprovider in built to be able to handle any type of filtering you might need.
While the filterpane comes with some built in filtertypes, they are only built to cover the most common use cases.

If you need something more specific, you have full freedom to do so.
Either by building from scratch or just simply taking the prebuilt components, and make your own take on them.

> It is recommended to be familiar with the FilterProvider when writing your own filter.  
> Check out the [Filter Provider page](?path=/docs/filterpane-filterprovider--page) for more details

## How to register your filter with the FilterProvider

To get the filterprovider to acknowledge your component, it needs to be registered with the filter provider store.
This can be done through the `useFilterContext` hook.

> Read about useFilterContext [here](?path=/docs/filterpane-filterprovider--page#usefiltercontext)

A typical way to register a filter would be like shown below.

```tsx
const { store } = useFilterContext();
useEffect(() => {
  store.registerFilter(key, filterFunction);
  store.registerFilterSettings(filter);
  return () => store.unRegisterFilter(key);
}, [key, filterFn, filter]);
```

Using the `store` we register our filtering function with `registerFilter` and `unRegisterFilter`.
`registerFilter` add the filterFn to the filtering process, and `unRegisterFilter` removes it again.
`registerFilterSettings` adds the entire filter object to the store, making it accessible where its needed.

In here we also `registerFilterSettings` .
This adds all the settings for given filter to the context, and its accessible where you might need it.
Very useful if you want get information on your filters outside the actual filter component.

> Be ware of unregister when running in a useEffect callback. As this Removes the filter on umount.
> You can read more on register and unregister filters [here](?path=/docs/filterpane-filterpane--filterpane#registering-filters-and-filter-settings)

Not registering the filter is also an option. If the filter never get registered, it will never be part of the filtering process.
This can be use full if you have something is belongs with the filter, but it dosnt acutally filter the data.
The component can be built in the same way as we will go through as you read on.
Using the same hooks and using the selection handling.
An example use is data organization, group by. A group by will impact the data, but not acutally filter it.
A component can react to that selection, and update the grouping accordingly.

## Using hooks to handle data

There are a couple use full hooks that can help us keep control over the options, counters , selection and changes as the filters updates.
We will go over the use of these below

> The hooks has been made to hide the complexity of `RxJS`. They should be flexible enough for any situation.  
> If you find yourself in a situation where you will want to go around these hooks, you will need work with [RxJS](https://rxjs.dev/) to accomplish want you need.

You can choose to use all or none of these hooks. They can be called in any in your component.

### useFilterChangeHandler

Initiate the hook by passing they filter key and a selection update function.
Below is how this is done for a checkbox.

```tsx
const selectionUpdate = (change: { key: string; checked: boolean }, selection: string[]) => {
  if (change.checked) return [...selection, change.key];
  selection.splice(selection.indexOf(change.key), 1);
  return [...selection];
};

const handleSelectionChange = useFilterChangeHandler('myFilterkey', selectionUpdate);
```

selectionUpdate will be a function that takes in a `change-object`, the `change` type is defined by you.
Giving you the ability to pass in any data you need. Here we pass in a `key`, which represents the Option we selected.
Then `checked` a boolean, telling us if the option is to be added or not. We also get the current selection.
We then decides how the selection is updated and returns the full object.
When returned the filter process will run. And your dataset will be filtered again.

### useFilterOptionsBuilder

Initiate hook by giving it the `optionsBuilderFn`
this function builds all the options for that should be available in the filter.

```tsx
const optionsBuilderFn = (data: DataType[]): FilterOptions => {
  const options = data.reduce((curr: Record<string, FilterOption>, item) => {
    const option = item.myDataAttribute;

    curr[option] = {
      key: option,
      searchString: option,
      label: option,
    };

    return curr;
  }, {});

  return {
    options,
    sortOrder: Object.keys(options).sort((a, b) => a.localeCompare(b)),
  };
};

const filterOptions = useFilterOptionsBuilder(optionsBuilderFn(data));
```

This optionsbuilder will reduce the dataSet to a Record of options.
Where each options is unique, and can be used by your component to "print" out the options.
The options builder only runs once on load, and will not be recalculated when the filter process runs.

The sortOrder, can be used to control the sorting of all the options. Sorting a Record can be difficult.
This is there to help with that, but is not mandatory.
Also there is nothing stopping you from returning other options in the object here.
Just extend the FilterOptions type.

### useFilterOptionsCounter

Initiate the hook by giving it the filter key and a counterFn.
The counterFn should be returning a `Record` where all options in the `filtered data set` is counted.
These options string need to correspond with the string the options builder creates. Or they will not be matched.
Still there is no direct connection between `useFilterOptionsCounter` and `useFilterOptionsBuilder`.

```tsx
const counterFn = (data: Person[] ): Record<string, number> =>
  data.reduce<Record<string, number>>((counters, item) => ({
    ...c, [item.myDataAttribute]: (counters[myDataAttribute] || 0) + 1 ;
  }), {});

const currentOptionsCounters = useFilterOptionsCounter(key, counterFn);
```

counterFn will receive the current filtered data set and then count all the occurrences of given "data" in myDataAttribute.
Returned as a Record<string,number> format.

This can the be used by the component, to match with the options in the filterOptions, to get the current count.
If the count is 0 or otherwise missing, the options is no longer available in the dataset.

The checkbox filter uses the counters to tell the user how many time the option is in current dataset.
It also filters the options based on the counters, if the option is missing or is 0, it is not shown.

> At first it might look natural to do the filter options and counting in one operation.
> Do not be tempted by this, there are various edge cases that can occur when you dont have track of all your options.
> Which might not be immediately obvious and will probably cause some bugs later on.

### useFilterSelection

Initiate hook with the filter key and type of the selection.
Simply returns the filters current selection.

```tsx
const currentOptionsSelection = useFilterSelection<string[]>(key);
```

As per example, currentOptionsSelection should now be an array of string.
string represent the key of your `filterOptions`.
The filterprovider uses this selection when it runs the filterProcess.
This is the object that gets passed to you in the `useFilterChangeHandler` hook.
Needed for determening how you filter should be set up.
For example in a `Checkbox filter`, the selection tells you which options should be selected in the UI.

### Building your component.

With these hooks set up you have all the data and utility you should need, to create the filter of your dreams.
There is no real hard rules on how a filter should look or feel.

I would recommend the `CheckBoxFilter` as a nice reference component.
It uses all the mentioned hooks and is a fairly straight forward component.
